# c++11新特性

<!-- TOC -->

- [c++11新特性](#c11%e6%96%b0%e7%89%b9%e6%80%a7)
  - [1 类型推导(auto & decltype)](#1-%e7%b1%bb%e5%9e%8b%e6%8e%a8%e5%af%bcauto--decltype)
    - [1.1 auto关键字](#11-auto%e5%85%b3%e9%94%ae%e5%ad%97)
    - [1.2 decltype关键字](#12-decltype%e5%85%b3%e9%94%ae%e5%ad%97)
    - [1.3 auto和decltype搭配使用](#13-auto%e5%92%8cdecltype%e6%90%ad%e9%85%8d%e4%bd%bf%e7%94%a8)
  - [2 左值右值](#2-%e5%b7%a6%e5%80%bc%e5%8f%b3%e5%80%bc)
    - [2.1 左值引用和右值引用](#21-%e5%b7%a6%e5%80%bc%e5%bc%95%e7%94%a8%e5%92%8c%e5%8f%b3%e5%80%bc%e5%bc%95%e7%94%a8)
    - [2.2 转发引用(forwarding reference)](#22-%e8%bd%ac%e5%8f%91%e5%bc%95%e7%94%a8forwarding-reference)
    - [2.3 移动语义](#23-%e7%a7%bb%e5%8a%a8%e8%af%ad%e4%b9%89)
    - [2.3 完美转发(perfect forwarding)](#23-%e5%ae%8c%e7%be%8e%e8%bd%ac%e5%8f%91perfect-forwarding)

<!-- /TOC -->

## 1 类型推导(auto & decltype)

C++11引入了auto和decltype关键字，使用他们可以在编译期就推导出变量或者表达式的类型

- auto:让编译器在编译阶段就推导出变量的类型
- decltype:让编译器在编译阶段就推导出表达式的类型，表达式实际不会进行运算

### 1.1 auto关键字

```cpp
auto e; // error，使用auto必须马上初始化，否则无法推导类型
int i = 10;
auto a = i, &b = i, *c = &i; // a是int，b是i的引用，c是i的指针，auto就相当于int
auto d = 0, f = 1.0; // error，0和1.0类型不同，对于编译器有二义性，没法推导


void func(auto value) {} // error，auto不能用作函数参数

class A {
    auto a = 1; // error，在类中auto不能用作非静态成员变量
    static auto b = 1; // error，这里与auto无关，正常static int b = 1也不可以
    static const auto int c = 1; // ok
};

void func2() {
    int a[10] = {0};
    auto b = a; // ok
    auto c[10] = a; // error，auto不能定义数组，可以定义指针
    vector<int> d;
    vector<auto> f = d; // error，auto无法推导出模板参数
}
```

**规则：**  

- auto的使用必须马上初始化，否则无法推导类型
- auto在一行定义多个变量时，各个变量的推导不能产生二义性，否则编译失败
- auto不能用作函数参数
- 在类中auto不能用作非静态成员变量
- auto不能定义数组，可以定义指针
- auto无法推导出模板参数

**auto与const和volatile搭配使用：**

- 在不声明为引用或指针时，auto会忽略等号右边的引用类型和cv限定
- 在声明为引用或者指针时，auto会保留等号右边的引用和cv属性
- 用 auto 声明指针类型时，用 auto 和 auto* 没有任何区别，但是！！！用 auto 声明引用类型时则必须加 &

```cpp
int i = 0;
auto *a = &i; // a是int*
auto &b = i; // b是int&
auto c = b; // c是int，忽略了引用

const auto d = i; // d是const int，是一个常量
auto e = d; // e是int，只是把d的值拿来赋给e，e是可读可写变量

const auto& f = e; // f是const int&，是一个常引用，不能通过引用来改变变量的值
auto &g = f; // g是const int&，
```

### 1.2 decltype关键字

```cpp

int func() { return 0; }
decltype(func()) i; // i为int类型

int x = 0;
decltype(x) y; // y是int类型
decltype(x + y) z; // z是int类型


cont int &i = 1;
int a = 2;
decltype(i) b = 2; // b是const int&
```

**规则：** 对于decltype(exp)有

- decltype不会像auto一样忽略引用和cv属性，decltype会保留表达式的引用和cv属性
- exp是表达式，decltype(exp)和exp类型相同
- exp是函数调用，decltype(exp)和函数返回值类型相同
- 其它情况，若exp是左值，decltype(exp)是exp类型的左值引用

### 1.3 auto和decltype搭配使用

auto和decltype一般配合使用在**推导函数返回值的类型**问题上  

```cpp
template<typename T, typename U>
decltype(t + u) add(T t, U u)       // t和u尚未定义
{
    return t + u;
}
```

这段代码在C++11上是编译不过的，因为在decltype(t +u)推导时，t和u尚未定义，就会编译出错，所以有了下面的叫做**返回类型后置**的配合使用方法:

```cpp
template<typename T, typename U>
auto add(T t, U u) -> decltype(t + u)//返回类型后置
{
    return t + u;
}
```

**返回值后置类型语法**就是为了解决函数返回值类型依赖于参数但却难以确定返回值类型的问题。

## 2 左值右值

左值实际上指的是某个内存地址，而右值指的就是那个数值，这个数值是暂时的，可能没有明确的地址，也可能只出现在一个寄存器中。

||左值|右值|
|-|-|-|
|概念1|可以取地址并且有名字的东西|不能取地址的没有名字的东西|
|概念2|可以放到等号左边的东西|不可以放到等号左边的东西|
**左值一般有：**  

- 函数名和变量名
- 返回左值引用的函数调用
- 前置自增自减表达式++i、--i
- 由**赋值表达式**或**赋值运算符**连接的表达式(a=b, a += b等)
- 解引用表达式*p
- 字符串字面值"abcdef"

**右值一般有：** 纯右值、将亡值  

1. 纯右值：运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值。
    - 除字符串字面值外的字面值
    - 返回非引用类型的函数调用
    - 后置自增自减表达式i++、i--
    - 算术表达式(a+b, a*b, a&&b, a==b等)
    - 取地址表达式等(&a)
2. 将亡值：通常指将要被移动的对象、T&&函数的返回值、std::move函数的返回值、转换为T&&类型转换函数的返回值，将亡值可以理解为即将要销毁的值，通过“盗取”其它变量内存空间方式获取的值，在确保其它变量不再被使用或者即将被销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期，常用来完成移动构造或者移动赋值的特殊任务。

### 2.1 左值引用和右值引用

- 左值引用（对左值进行引用的类型），等号右边的值必须可以取地址，如果不能取地址，则可以使用const引用形式（常引用）
- 右值引用（对右值进行引用的类型），表达式等号右边的值需要是右值，可以使用std::move函数强制把左值转换为右值。

||左值引用|右值引用|
|-|-|-|
|区别|non-const左值引用只能用non-const左值来初始化<br>**const左值引用可以接受右值**（常引用）|右值引用只能用右值初始化|
|作用|就是日常的引用作用|用来延长对象的生命周期<br>初始化后的右值引用将变成一个左值，如果是non-const引用的话还可以被赋值<br>用于函数参数来实现移动语义和完美转发|

```cpp
type &name = exp; // 左值引用
type &&name = exp; // 右值引用，一般来说作用是支持移动操作

int a = 5;
int &b = a; // b是左值引用
b = 4;
int &c = 10; // error，10无法取地址，无法进行引用
const int &d = 10; // ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址


int a = 4;
int &&b = a; // error, a是左值
int &&c = std::move(a); // ok,a由左值->右值引用
```

### 2.2 转发引用(forwarding reference)

当 **&&** 出现在类型声明时，有如下两种意思：

- 能确定下来，就是右值引用
- 不能确定下来，可以是右值引用或左值引用，称之为转发引用（forwarding reference）

**转发引用：** 如果一个变量或参数的声明有 T&& 的形式，并且 T 是需要推导的类型（deduced type T），那么这个变量或参数是个 forwarding reference.否则，就是个右值引用

||转发引用(forwarding reference)|
|-|-|
|出现场景|需要类型推导的地方均有可能：<br>函数模板参数<br>typedef<br>auto或decltype|
|必须初始化|被左值初始化就是左值引用<br>被右值初始化就是右值引用|


### 2.3 移动语义

 通过移动而不是复制来避免无必要的资源浪费

**std::move()函数作用：** 它接受一个参数，然后返回一个该参数对应的右值引用.

深拷贝就是在拷贝对象时，如果被拷贝对象内部还有指针引用指向其它资源，自己需要重新开辟一块新内存存储资源，而不是简单的赋值。移动语义就是用来实现深拷贝的功能，同时减去很多拷贝负担  
之前的拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源，而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用，通过C++11新增的移动语义可以省去很多拷贝负担，怎么利用移动语义呢，是通过**移动构造函数**和**移动赋值运算符**。

```cpp

class A {
public:
    A(int size) : size_(size) {data_ = new int[size];}
    A(){}
    A(const A& a)//拷贝构造函数，形参是左值引用，完成对整个对象或变量的拷贝
    {
        size_ = a.size_;
        data_ = new int[size_];
        cout << "copy " << endl;
    }
    A(A&& a)//移动拷贝函数，形参是右值引用，生成一个指针指向源对象或变量的地址，接管源对象的内存
    {
        this->data_ = a.data_;
        a.data_ = nullptr;
        cout << "move " << endl;
    }
    ~A()
    {
        if (data_ != nullptr) delete[] data_;
    }
    int *data_;
    int size_;
};
int main()
{
    A a(10);//调用的是构造函数A(int size)
    A b = a;//调用的是拷贝构造函数A(const A& a)
    A c = std::move(a); // 调用移动构造函数A(A&& a)
    return 0;
}
```

**std::move()将左值转换为对应的右值引用类型**，如果不使用std::move()，会有很大的拷贝代价，使用移动语义可以避免很多无用的拷贝，提供程序性能，C++所有的STL都实现了移动语义，方便我们使用。例如：

```cpp
std::vector<string> vecs;
...
std::vector<string> vecm = std::move(vecs); // 免去很多拷贝
```

注意：移动语义仅针对于那些实现了移动构造函数的类的对象，如果没有自已定义移动构造函数，使用std::move()会默认调用拷贝构造函数，对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数。

### 2.3 完美转发(perfect forwarding)

完美转发指可以写一个接受任意实参的函数模板，并转发到其它函数，**目标函数**会收到与**转发函数**完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。  
**forward() 函数的作用：** 它接受一个参数，然后返回该参数本来所对应的类型的引用。
# 输入输出流

- cin是标准输入流对象，即istream类的对象，主要用于从标准输入读取数据，这里的标准输入，指的是终端的键盘。
- cout是流的对象，即ostream类的对象
- cerr是标准错误输出流的对象，也是ostream 类的对象。这里的标准输出指的是终端键盘，标准错误输出指的是终端的屏幕

## 1 cin对象

|方法|介绍|说明|
|-|-|-|
|cin>>|等价于cin.operator>>()，即调用成员函数operator>>()进行读取数据|从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin>>会将其忽略并清除,继续读取下一个字符<br>若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin>>不做处理。<br>不想略过空白字符，那就使用 noskipws 流控制。比如`cin>>noskipws>>input`|
|cin.get()|||

- 当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键(\r)会被转换为一个换行符\n，这个换行符\n也会被存储在cin的缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了123456这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是7 ，而不是6。
- cin读取数据也是从缓冲区中获取数据，缓冲区为空时，cin的成员函数会阻塞等待数据的到来，一旦缓冲区中有数据，就触发cin的成员函数去读取数据。当cin>>从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，cin>>会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，字符后面的分隔符是残留在缓冲区的，cin>>不做处理。

**while(cin)与while(cin>>s):**

```cpp
假设cin>>whatever无效，即输入失败，那么具体循环情况如下：
只有输入的内容有效才会执行loop
while(cin >> x) {   //此时的cin是当前的读取状态，只有读取成功才为true
    // code that Dosen't run
}
不管你输入的内容是有效还是无效，都会执行loop
while(cin) {    //此处的cin是上一次读取的状态，如果上一次读取成功，就会得到一个虚假的true(不是当前读取能否成功的状态)，进而继续循环
    cin >> y;
    //code that does run,  even if the previous read failed
    //输入失败的话，会继续用旧的y值再执行一次循环，比上面要多执行一次循环
}
```

**cin状态：**

|常量|含义|对应函数|failbit位|eofbit位|badbit位|
|-|-|-|-|-|-|
|ios::failbit|cin.fail()|输入（输出）流出现非致命错误，可挽回|1|0|0|
|ios::badbit|cin.bad()|输入（输出）流出现致命错误，不可挽回|0|0|1|
|ios::eofbit|cin.eof()|已经到达文件尾(end of file)|0|1|0|
|ios::goodbit|cin.good()|流状态完全正常|0|0|0|

**与cin状态有关的函数：**

|函数|描述|
|-|-|
|cin.sync()|清除缓冲区|
|cin.clear()| 清除cin错误状态|
|cin.ignore(int n,char c)|从输入流（cin）中提取字符，提取的字符被忽略（ignore），不被使用,每抛弃一个字符，它都要计数和比较字符：如果计数值达到n或者被抛弃的字符是'c'，则cin.ignore()函数执行终止；否则，它继续等待。它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容，消除上一次输入对下一次输入的影响。|

cin.ignore()作用示例：`cin.ignore( 1024,  '\n' );`，通常把第一个参数设置得足够大，这样实际上总是只有第二个参数'\n'起作用，所以这一句就是把回车（包括回车）之前的所以字符从输入缓冲（流）中清除出去。

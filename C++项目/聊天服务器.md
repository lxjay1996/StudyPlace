# 聊天服务器

linux，C++,集群，服务器的中间件

- 基于局域网的聊天：单机版本（只有一个服务器）---->横向扩展多个服务器（服务器的集群技术），以提供更多人使用

- 服务器集群里涉及到负载均衡和反向代理---->这里使用Nginx的tcp负载均衡部署
- 跨服务器通信需要用到中间件，redis的消息队列实现信息的转发，解耦各个服务器之间的硬链接

- 数据的传输使用json进行序列化和反序列化
- CMAKE构建项目的编译环境

项目实现的需求：

- 用户的注册、登录、注销
- 添加好友、群组
- 好友聊天、群组聊天
- Nginx配置TCP负载均衡
- 集群聊天系统支持客户端跨服务器通信

## 1. json

- 轻量级的数据交换格式，使用Javascript语法来描述数据对象，但是json独立于编程语言
- json for modern c++，使用起来类似于stl容器
- 与json类似的还有：xml/protobuf

消息分类的, tcp网络发送的是字节流

```json
json数据对象
msg_type:2      数据序列化
from:XXX        -------->       字节流/字符流json字符串
to:XXX
msg:XXXXXX
								json数据对象
                                msg_type:2
json            数据反序列化     from:XXX
字节流/字符流     -------->      to:XXX
                                msg:XXXXXX
```

### 1.1 语法规则

- 数据在名称/值对中：`"字段名称":值`
- 数据由逗号分隔
- 大括号保存对象
- 中括号保存数组

- json的值可以是：6种
  - 数字（整数或浮点数）
  - 字符串（在双引号中）
  - bool值
  - 数组（在中括号中）
  - 对象（在大括号中）
  - null

- json对象：在大括号中书写，可以包含多个`key:value`，每个`key:value`之间用逗号分隔.
  - key:必须是字符串
  - value:可以是值的6种类型
  - 对象通过.或[]来访问key对应的value

- 与xml对比：
  - 没有结束标签，长度更短，读写快
  - 可以使用数组

## 2 muduo网络库

- 底层：epoll + linux的pthread线程库；基于事件循环：一个线程一个事件循环(one loop per thread)
- 多个客户端向服务器发出请求(通过各个IO)，epoll对多路IO进行管理，一旦某个IO里监听到数据，就会唤起一个线程去处理----epoll就是实现这事件循环监听的一个技术
- 服务器要做到高并发，所以服务器要用到muduo库编程
- 客户端只是向服务端请求服务，客户端本身并不需要一个高并发的性能要求，可以不用muduo库编程

**关于多线程：**

- 进程是操作系统分配资源、管理的最小单位；线程是CPU执行运算的最小单位，是系统调度的最小单位，CPU看见的就是线程；协程则是用户自定义的轻量级线程，不属于操作系统层面，一个线程可以包含多个协程。
- 单线程与多线程的出现主要是由于 I/O （磁盘I/O、网络I/O、数据库I/O）的高延时，利用CPU在等待期间的处理能力，提高cpu的利用率
- 线程的状态：创建、就绪、运行、阻塞、退出
- 线程是OS底层的API，在创建线程与上下文切换过程中，会消耗较多的时间，因此仍有进一步提升 CPU 效率的空间。
- 线程的调度是由操作系统完成，而协程的调度是由用户完成，所以避免了上下文切换，提高了效率
- 协程则是编程语言级别的用户态，避免了用户态与内核态切换过程中的时间损耗。
- 线程进程都是同步机制，而协程则是异步
- **进程线程的上下文切换：** 从当前执行任务切换到另一个任务执行的过程。但是，为了确保下次能从正确的位置继续执行，在切换之前，会保存上一个任务的状态。进程上下文切换与线程上下文切换最主要的区别就是线程的切换虚拟空间内存是相同的（因为都是属于自己的进程），但是，进程切换的虚拟空间内存则是不同的。同时，这两种上下文切换的处理都是通过操作系统内核来完成的。
- 线程的创建、销毁、切换都会对应着CPU资源的消耗（切换到内核态），使用线程池技术可以优化前两个问题：创建就从线程池中唤醒一个线程，销毁就把该线程归还线程池，切换的消耗无法避免（协程可以优化），协程因为是用户自定义的，所以不用进入内核态就可以完成切换

**关于内存分配：**

- <https://blog.csdn.net/yusiguyuan/article/details/39496057>
- new --> malloc --> 系统调用（以128k为分界线）brk 或 mmap
- brk是将数据段(.data)的最高地址指针_edata往高地址推；就是在堆顶往高地址推,增加堆顶的高度
- mmap是在堆和栈中间的文件映射区，分配一块空闲的虚拟内存
- 两种方式分配的都是虚拟内存，没有分配物理内存。只有在第一次访问到已分配的虚拟内存空间的时候，会发生缺页中断，OS负责分配真实内存，然后建立虚拟内存和物理内存之间的映射（页映射）。
- 原因：brk分配的内存需要等到高地址释放以后才能释放（这样容易产生内存碎片，我们当然希望碎片越小越好），而mmap分配的内存可以立马单独释放掉

### 2.1 epoll

- 对于epoll的讲解：<https://zhuanlan.zhihu.com/p/63179839>
- 底层：早期的时候 epoll的实现是一个哈希表，但是后来由于占用空间比较大，改为了红黑树和链表。
- select, poll, epoll 都是I/O多路复用的具体实现，他们出现是有先后顺序的。
- 三个函数：
  - epoll_creat():
  - epoll_ctl():
  - epoll_wait(): 多长时间轮询一次,轮询一次返回的是有几个IO中存在数据，需要进行读写；返回的是个数

### 2.2 服务端

**服务器类的开发：**

- 组合Tcpserver对象
- 创建Eventloop事件循环对象的指针，保存通过构造函数传进来的事件循环对象，为了操作epoll
- 明确Tcpserver构造函数需要什么参数，输出ChatServer的构造函数
- 在当前的服务器类构造函数中，注册处理连接的回调函数和处理读写事件的回调函数
- 设置合适的服务端线程数量，muduo库会自己分配IO线程和work线程

注意回调函数：当相应的事件发生，去调用对应的回调函数

### 2.3 客户端

- 没有图形界面，通过命令发送消息
- 读写两个线程：读线程专门接受服务器推送过来的消息，写线程专门专门接收用户的输入，发送相应的业务数据
- 主线程作为发送线程，子线程用作接收线程
- 不需要高并发，使用原始的linuxTCP编程

## 3 模块开发

整个项目由：网络模块 + 业务模块 + 数据模块 三大部分构成

### 3.1 网络模块 - chatserver

- 服务器类的定义与实现：chatserver.hpp + chatserver.cpp
- 监听服务端的各个端口号，一旦接受到客户端的连接、读写事件请求，便通过回调函数调用相应的业务代码
- 通过回调函数，实现网络模块代码和业务模块代码的解耦
- 例子回调的作用：网络模块接收到客户端的请求（比如是登录请求），执行回调操作（要回调，就要事先把登录请求消息，注册上对应的操作，这样一接收到该消息类型，就调用相应的操作），找到相应的登录业务模块执行

### 3.2 业务模块 - chatservice

- 使用单例模式实现业务类
- 只需在业务模块的内部将相应的消息id和对应的事件回调进行绑定，就可以让网络模块通过消息id调用业务模块对应的事件处理。这样，在网络层见不到真正的业务层方法调用，从而实现网络模块和业务模块的真正解耦。

### 3.3 数据模块 - db

- 对数据库进行操作
- ORM:对象关系映射框架，业务层操作的都是对象， 数据层才是操作具体的数据库
- 用户表的映射类：user.hpp 映射user表的字段
- 用户表的数据操作类：usermodel.hpp 对用户表进行具体的操作：增删改查！
- 在业务层面只是用到model类，业务层不做具体的数据库相关操作，数据库相关的操作都封装在model类里面，而且model类给业务层提供都是对象，并不是数据库表的具体字段。

## 3 业务的逻辑

**连接相关的map表：**

- 用户1给用户2发消息的过程：客户端1把消息推给服务器，服务器再根据消息的具体要发送的对象，将消息推给目标客户端2，所以服务器是一个长连接，服务器不仅要被动接受消息，也要主动推送消息给别人
- 但是服务端接收到一个发送对象的id是2后，怎么能知道2的通信连接在哪呢？所以呢要记录用户的连接信息，只要登录成功就建立一个连接，然后就可以把这个连接存储下来。用一个字典把**用户的id和通信连接**保存下来，做到一个用户一个通信连接。这样，通过id就可以找到相应的连接
- 显然，在客户端、服务器工作过程中可能会有新的用户接入、建立新的连接和登出，所以上面的字典读写一定要设计成多线程安全的。**读写事件的回调函数onmessage本身就会被多个线程调用**，因为不同用户可能在不同的工作线程中响应。所以，业务层的方法本身就会在多线程的环境里
- 要注意业务层多线程同时向map表里面添加东西，C++stl都是线程不安全的。使用互斥锁lockgard保证用户连接map的线程安全
- 数据库的并发操作和线程安全，则不用管，是由mysql来保证

**1对1的聊天业务：**

- 该业务的json数据包含哪些字段：msgid,id,from,to,msg
- 服务端接收到发送方的json数据后，通过id查看发送对象是否在线，在线的话直接通过存储在线连接信息的map表找到对象，把消息推送给对应的客户端。如果不在线，那么就存入对应的离线消息表，等发送对象上线后，自动将消息推送给他
- **离线消息：** 数据层面，会有一个专门用来存储离线消息的表，存储要发送对象的id和消息，待用户上线后，直接从离线消息表里查询是否有离线消息，有的话直接推送给他，然后再把离线消息表中对应的消息删除掉。
- **数据恢复：** 服务器有可能因为突然断电等原因停止工作，所以每次服务器重启的时候都要设计一个恢复操作，重置用户状态。**客户端异常断开** 也需要重置用户的状态，并把用户在线连接表map里的连接信息给删除掉

**好友业务：**

- 用户一登录，就会从好友表中拉取好友列表，显示在客户端中(好友的id,name,state)。使用的是多表的联合查询(user表和friend表)，userid -> friendid(很多)
- 用户添加好友请求发送给服务器，服务器把好友关系添加到好友表中去，这里设计的添加好友业务无需征求对方的同意
- 数据层，userid 和 friendid 是联合主键，好友之间只需记录一次就行了，不用重复记录。

**群组业务：**

- 三个功能：创建群、加入群、群聊
- 组和成员的关系：多对多，所以要有一个中间表（groupuser表）来体现他们之间的隶属关系

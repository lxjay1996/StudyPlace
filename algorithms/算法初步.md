# 算法初步

## 1  排序

- 所谓排序指的是将一个记录序列重新排列成一个按关键码有序的序列.  
- 排序过程一般由两步组成:  
 i. 比较---关键码之间的比较  
 ii.移动---记录从一个位置移动到另一个位置

- 几大排序思想:

排序思想|排序名称
:-:|:-:
插入排序|直接插入排序+希尔排序
交换排序|冒泡排序+快速排序
选择排序|简单选择排序+堆排序
归并排序|非递归+递归
分配排序|桶式排序+基数排序

### 1.1 选择排序(selection sort)

- **主要思想:** 每趟排序,在当前无序序列中选出关键码最小的记录,添加到有序序列中.
- 特点:记录移动次数较少

#### 1.1.1 简单选择排序(simple selection sort)

**过程:**  
(1) 将整个记录序列分为有序区和无序区,有序区初始化为空,无序区初始化为整个记录序列  
(2) 在无序区中选择关键码最小的记录,将它与无序区中的第一个记录交换.使得有序区扩展了一个记录,无序区减少了一个记录.  
(3) 不断重复(2),直至无序区只剩下一个记录为止.  

```cpp
void selectSort(int R[], int n) {//0号单元用作交换操作的暂存单元
    for (i=1; i<n; i++){//n个记录需要n-1趟操作,i~n为无序区
    index = i;
    for (j=i; j<=n; j++){ //在无序区中选择最小记录
        if (R[j]<R[index]) index=j;
    }
    if (index!=i) { //将无序区的最小记录与第一个记录交换
        int temp = R[i]; //temp就是暂存单元,可以是R[0]
        R[i] = R[index];
        R[index] = temp;
        }
    }
}
```

**分析:**  

- 时间复杂度:O(n<sup>2</sup>)
- 只需要一个用来作为记录交换的暂存单元
- 不稳定的排序方法

#### 1.1.2 堆排序(heap sort)  

对simple selection sort进行改进:在无序区中选出最小关键码的同时,也找出较小的关键码,减少了后面的比较次数,从而提高整体效率.

### 1.2 交换排序

### 1.3 插入排序(insertion sort)  

- **主要思想:**  每次将一个无序区的记录按其关键码的大小插入到有序序列中.

#### 1.3.1 直接插入排序(straight insertion sort)

**过程:**  
(1) 划分有序区和无序区,有序区初始化为待排记录序列的第一个记录,无序区初始化为所有剩余记录  
(2) 将无序区的第一个记录插入到有序区的合适位置,使得有序区增加一个记录,无序区减少一个记录  
(3) 重复执行(2)直到无序区没有记录  

```c++
void InsertSort(int R[], int n) //0号单元用作暂存单元和哨兵
{
    for (i=2; i<=n; i++) //无序区为i~n,共n-1趟
    {
        R[0] = R[i]; //暂存待插关键码,并设置哨兵,避免数组下标越界
        for (j=i-1; R[0]<R[j]; j--) //在有序区1~i-1中查找待插入位置
        { R[j+1] = R[j]; } //R[i]插入位置的后面记录应该整体后移一位,摞出位置
        R[j+1] = R[0]; //在最终找到位置的地方插入记录R[i]
    }
}
```

**分析:**  

- 时间复杂度:O(n<sup>2</sup>)
- 只需要一个记录的辅助空间R[0],用来作为待插入记录的暂存单元(不至于因记录的后移而丢失R[i]的内容),和查找记录的插入过程中的哨兵.
- 是一种稳定的排序方法.
- 待排序列基本有序时,才是最佳排序方法.

#### 1.3.2 希尔排序(shell sort)  

对straight insertion sort进行改进:由于直接插入排序算法简单,则在待排序记录个数较少时效率也高.  
**主要思想:**  先将整个待排记录序列分割成若干个子序列,在子序列内分别进行直接插入排序,待整个序列基本有序时,再对全体记录进行一次直接插入排序.

## 2 散列(hash)

- 散列表（hash table）：采用散列技术将记录存储在一块连续的存储空间（这块存储空间称为散列表）中；
- 散列函数（hash function）：将关键码映射为散列表中适当存储位置的函数；
- 散列地址（hash address）：所得的存储位置；
- 冲突（collision）：两个不同的记录通过散列函数计算出同样的散列地址，要存放在同一个存储位置中。
- 同义词（synonym）：两个不同的关键码$k_1\not=k_2$，有$H(k_1)=H(k_2)$，$k_1和k_2$相对于H称作同义词。

**散列既是一种存储方法，也是一种查找方法。但是散列不是一种完整的存储结构，**因为它只通过记录的关键码来定位该记录，很难完整的表达记录之间的逻辑关系，**所以，散列主要是面向查找的存储结构。**

**散列过程：**
（1）**存储记录时**，通过散列函数计算记录的散列地址，并按此地址来存储该记录；
（2）**查找记录时**，通过同样的散列函数计算记录的散列地址，按此地址来访问记录。

散列表一般**不适用于多个记录有相同关键码的情况，也不适用于范围查找**（因为散列查找是计算查找，而不是比较查找，所以不大可能找到最大啦、最小啦、某一范围啦之类的记录）。**最适用于：如果有的话，哪个记录的关键码等于待查值。**

**两个主要问题：**
- 散列函数的设计
- 冲突的处理

## 3 递归

## 4 贪心

## 5 二分





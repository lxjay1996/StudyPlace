# 算法初步
## 1  排序
- 所谓排序指的是将一个记录序列重新排列成一个按关键码有序的序列.
- 排序过程一般由两步组成:
	i. 比较---关键码之间的比较
	ii.移动---记录从一个位置移动到另一个位置

- 几大排序思想:
排序思想|排序名称
:-:|:-:
插入排序|直接插入排序+希尔排序
交换排序|冒泡排序+快速排序
选择排序|简单选择排序+堆排序
归并排序|非递归+递归
分配排序|桶式排序+基数排序

### 1.1 选择排序(selection sort)
- 主要思想:每趟排序,在当前无序序列中选出关键码最小的记录,添加到有序序列中.
- 特点:记录移动次数较少

#### 1.1.1 简单选择排序(simple selection sort)
**过程:**
	(1) 将整个记录序列分为有序区和无序区,有序区初始化为空,无序区初始化为整个记录序列
	(2) 在无序区中选择关键码最小的记录,将它与无序区中的第一个记录交换.使得有序区扩展了一个记录,无序区减少了一个记录.
	(3) 不断重复(2),直至无序区只剩下一个记录为止.

```C++
void selectSort(int R[], int n) {	//0号单元用作交换操作的暂存单元
	for (i=1; i<n; i++){	//n个记录需要n-1趟操作,i~n为无序区
		index = i;
		for (j=i; j<=n; j++){	//在无序区中选择最小记录
			if (R[j]<R[index]) index=j;
		}
		if (index!=i) {	//将无序区的最小记录与第一个记录交换
		int temp = R[i];	//temp就是暂存单元,可以是R[0]
		R[i] = R[index];
		R[index] = temp;
		}
	}
}
```
**分析:**

- 时间复杂度:O(n<sup>2</sup>)
- 只需要一个用来作为记录交换的暂存单元
- 不稳定的排序方法

#### 1.1.2 堆排序(heap sort)
对simple selection sort进行改进:在无序区中选出最小关键码的同时,也找出较小的关键码,减少了后面的比较次数,从而提高整体效率.

### 1.2 交换排序


### 1.3 插入排序(insertion sort)
- **主要思想:**每次将一个无序区的记录按其关键码的大小插入到有序序列中.

### 1.3.1 直接插入排序(straight insertion sort)

**过程:**
	(1) 划分有序区和无序区,有序区初始化为待排记录序列的第一个记录,无序区初始化为所有剩余记录
	(2) 将无序区的第一个记录插入到有序区的合适位置,使得有序区增加一个记录,无序区减少一个记录
	(3) 重复执行(2)直到无序区没有记录
	
```c++
void InsertSort(int R[], int n) //0号单元用作暂存单元和哨兵
{
	for (i=2; i<=n; i++) //无序区为i~n,共n-1趟
	{
		R[0] = R[i]; //暂存待插关键码,并设置哨兵,避免数组下标越界
		for (j=i-1; R[0]<R[j]; j--) //在有序区1~i-1中查找待插入位置
		{ R[j+1] = R[j]; } //R[i]插入位置的后面记录应该整体后移一位,摞出位置
		R[j+1] = R[0]; //在最终找到位置的地方插入记录R[i]
	}
}
```

**分析:**

- 时间复杂度:O(n<sup>2</sup>)
- 只需要一个记录的辅助空间R[0],用来作为待插入记录的暂存单元(不至于因记录的后移而丢失R[i]的内容),和查找记录的插入过程中的哨兵.
- 是一种稳定的排序方法.
- 待排序列基本有序时,才是最佳排序方法.

### 1.3.2 希尔排序(shell sort)
对straight insertion sort进行改进:由于直接插入排序算法简单,则在待排序记录个数较少时效率也高.
**主要思想:**先将整个待排记录序列分割成若干个子序列,在子序列内分别进行直接插入排序,待整个序列基本有序时,再对全体记录进行一次直接插入排序.
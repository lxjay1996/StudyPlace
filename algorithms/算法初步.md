# 算法初步

<!-- TOC -->

- [算法初步](#%e7%ae%97%e6%b3%95%e5%88%9d%e6%ad%a5)
  - [1  排序](#1-%e6%8e%92%e5%ba%8f)
    - [1.1 选择排序(selection sort)](#11-%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8fselection-sort)
      - [1.1.1 简单选择排序(simple selection sort)](#111-%e7%ae%80%e5%8d%95%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8fsimple-selection-sort)
      - [1.1.2 堆排序(heap sort)](#112-%e5%a0%86%e6%8e%92%e5%ba%8fheap-sort)
    - [1.2 交换排序](#12-%e4%ba%a4%e6%8d%a2%e6%8e%92%e5%ba%8f)
      - [1.2.1 冒泡排序(bubble sort)](#121-%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8fbubble-sort)
      - [1.2.2 快速排序(quick sort)](#122-%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8fquick-sort)
    - [1.3 插入排序(insertion sort)](#13-%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8finsertion-sort)
      - [1.3.1 直接插入排序(straight insertion sort)](#131-%e7%9b%b4%e6%8e%a5%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8fstraight-insertion-sort)
      - [1.3.2 希尔排序(shell sort)](#132-%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8fshell-sort)
    - [1.4 归并排序(merge sort)](#14-%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8fmerge-sort)
  - [2 散列(hash)](#2-%e6%95%a3%e5%88%97hash)
    - [2.1 散列函数（hash function）](#21-%e6%95%a3%e5%88%97%e5%87%bd%e6%95%b0hash-function)
    - [2.2 冲突的处理](#22-%e5%86%b2%e7%aa%81%e7%9a%84%e5%a4%84%e7%90%86)
      - [2.2.1 线性探查法](#221-%e7%ba%bf%e6%80%a7%e6%8e%a2%e6%9f%a5%e6%b3%95)
      - [2.2.2 二次探查法](#222-%e4%ba%8c%e6%ac%a1%e6%8e%a2%e6%9f%a5%e6%b3%95)
      - [2.2.3 随机探查法](#223-%e9%9a%8f%e6%9c%ba%e6%8e%a2%e6%9f%a5%e6%b3%95)
      - [2.2.3 链地址法](#223-%e9%93%be%e5%9c%b0%e5%9d%80%e6%b3%95)
  - [3 递归](#3-%e9%80%92%e5%bd%92)
    - [3.1 分治(divide and conquer)](#31-%e5%88%86%e6%b2%bbdivide-and-conquer)
    - [3.2 递归](#32-%e9%80%92%e5%bd%92)
  - [4 贪心](#4-%e8%b4%aa%e5%bf%83)
  - [5 二分](#5-%e4%ba%8c%e5%88%86)
    - [5.1 二分查找](#51-%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be)
    - [5.2 快速幂](#52-%e5%bf%ab%e9%80%9f%e5%b9%82)
      - [5.2.1 快速幂的递归实现](#521-%e5%bf%ab%e9%80%9f%e5%b9%82%e7%9a%84%e9%80%92%e5%bd%92%e5%ae%9e%e7%8e%b0)
      - [5.2.3 快速幂的迭代实现](#523-%e5%bf%ab%e9%80%9f%e5%b9%82%e7%9a%84%e8%bf%ad%e4%bb%a3%e5%ae%9e%e7%8e%b0)
  - [6 two pointers](#6-two-pointers)

<!-- /TOC -->

## 1  排序

- 所谓排序指的是将一个记录序列重新排列成一个按关键码有序的序列.  
- 排序过程一般由两步组成:  
 i. 比较---关键码之间的比较  
 ii.移动---记录从一个位置移动到另一个位置

- 几大排序思想:

排序思想|排序名称
:-:|:-:
插入排序|直接插入排序+希尔排序
交换排序|冒泡排序+快速排序
选择排序|简单选择排序+堆排序
归并排序|非递归+递归
分配排序|桶式排序+基数排序

### 1.1 选择排序(selection sort)

- **主要思想:** 每趟排序,在当前无序序列中选出关键码最小的记录,添加到有序序列中.
- 特点:记录移动次数较少

#### 1.1.1 简单选择排序(simple selection sort)

**过程:**  
(1) 将整个记录序列分为有序区和无序区,有序区初始化为空,无序区初始化为整个记录序列  
(2) 在无序区中选择关键码最小的记录,将它与无序区中的第一个记录交换.使得有序区扩展了一个记录,无序区减少了一个记录.  
(3) 不断重复(2),直至无序区只剩下一个记录为止.  

```cpp
void selectSort(int R[], int n) {//0号单元用作交换操作的暂存单元
    for (i=1; i<n; i++){//n个记录需要n-1趟操作,i~n为无序区
    index = i;
    for (j=i; j<=n; j++){ //在无序区中选择最小记录
        if (R[j]<R[index]) index=j;
    }
    if (index!=i) { //将无序区的最小记录与第一个记录交换
        int temp = R[i]; //temp就是暂存单元,可以是R[0]
        R[i] = R[index];
        R[index] = temp;
        }
    }
}
```

**分析:**  

- 时间复杂度:$O(n^2)$
- 只需要一个用来作为记录交换的暂存单元
- 不稳定的排序方法

#### 1.1.2 堆排序(heap sort)  

对simple selection sort进行改进:在无序区中选出最小关键码的同时,也找出较小的关键码,减少了后面的比较次数,从而提高整体效率.

### 1.2 交换排序

**主要思想：** 在待排序列中选两个记录，对他们关键码进行比较，如果反序则交换它们位置  
交换排序，顾名思义，一定会需要交换操作，所以先完成两数交换函数：  

```cpp
void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}
```

#### 1.2.1 冒泡排序(bubble sort)

**思路：** 两两比较相邻记录的关键码，反序则交换，直到没有反序为止  

- 时间复杂为$O(n^2)$
- 是一种稳定的排序方法

```cpp
void BubbleSort(int r[], int n)
{
    int exchange = n-1;//第一趟排序是整个序列
    while(exchange != 0)//排序结束的条件：某一趟排序过程中没有进行记录交换
    {
        int bound = exchange;//本趟排序的边界
        exchange = 0;//重置交换标志，以便确定后面是否发生交换
        for(int i=0; i < bound; i++)//遍历
        {
            if(r[i] > r[i+1])//元素交换
            {
                swap(r[i], r[i+1]);
                exchang = i;//记录交换产生的位置，把该趟最后的exchange作为下一趟的边界
            }
        }
    }
}
```

#### 1.2.2 快速排序(quick sort)

**主要思路**：是对冒泡排序的一种改进。又称**分区交换排序**，首先选一个轴值povit(比较的基准)，将待排序列划分为两部分，左侧均不大于povit，右侧均不小于povit；然后分别对左右两侧重复上面操作，直到整个序列有序。  

**一次划分算法：**基于**tow pointers**思想：重复下面过程直到left=right  
（1）右侧扫描(right--)，直到r[left]>r[right]  
（2）如果存在划分区间，则swap(r[left], r[right]),并left++  
（3）左侧扫描(left++)，直到r[left]>r[right]  
（4）如果存在划分区间，则swap(r[left], r[right])，并right--  

```cpp
int Partition(int r[], int left, int right)
{
    while(left < right)
    {
        while(left < right && r[left] <= r[right]) right--;//右侧扫描
        if(left < right)
        {
            swap(r[left], r[right]);//将较小记录交换到前面
            left++;
        }
        while(left < right && r[left] <= r[right]) left++;//左侧扫描
        if(left < right)
        {
            swap(r[right], r[left]);//将较大记录交换到后面
            right--;
        }
    }
    return left;//轴值的最终记录

}
```

快速排序算法借助于递归来实现，若待排序列中只有一个记录，则递归结束，否则进行一次划分后，再分别对划分得到的两个子序列进行快速排序（即递归处理）.  

```cpp
void QuickSort(int r[], int left, int right)
{
    if(left < right)//递归边界
    {
        int povit = Partition(r, left, right);//一次划分
        QuickSort(r, left, povit-1);//递归左子区间
        QuickSort(r, povit+1, right);//递归右子区间
    }
}
```

- 时间复杂度为$O(nlogn)$
- 不稳定的一种排序

### 1.3 插入排序(insertion sort)  

- **主要思想:**  每次将一个无序区的记录按其关键码的大小插入到有序序列中.

#### 1.3.1 直接插入排序(straight insertion sort)

**过程:**  
(1) 划分有序区和无序区,有序区初始化为待排记录序列的第一个记录,无序区初始化为所有剩余记录  
(2) 将无序区的第一个记录插入到有序区的合适位置,使得有序区增加一个记录,无序区减少一个记录  
(3) 重复执行(2)直到无序区没有记录  

```c++
void InsertSort(int R[], int n) //0号单元用作暂存单元和哨兵
{
    for (i=2; i<=n; i++) //无序区为i~n,共n-1趟
    {
        R[0] = R[i]; //暂存待插关键码,并设置哨兵,避免数组下标越界
        for (j=i-1; R[0]<R[j]; j--) //在有序区1~i-1中查找待插入位置
        { R[j+1] = R[j]; } //R[i]插入位置的后面记录应该整体后移一位,摞出位置
        R[j+1] = R[0]; //在最终找到位置的地方插入记录R[i]
    }
}
```

**分析:**  

- 时间复杂度:$O(n^2)$
- 只需要一个记录的辅助空间R[0],用来作为待插入记录的暂存单元(不至于因记录的后移而丢失R[i]的内容),和查找记录的插入过程中的哨兵.
- 是一种稳定的排序方法.
- 待排序列基本有序时,才是最佳排序方法.

#### 1.3.2 希尔排序(shell sort)  

对straight insertion sort进行改进:由于直接插入排序算法简单,则在待排序记录个数较少时效率也高.  
**主要思想:**  先将整个待排记录序列分割成若干个子序列,在子序列内分别进行直接插入排序,待整个序列基本有序时,再对全体记录进行一次直接插入排序.

### 1.4 归并排序(merge sort)

**主要思想：** 将若干个有序序列逐步归并，最终归并为一个有序序列。  
最简单的就是**二路归并排序(2-way merge sort)**：将序列两两分组进行归并，第一次归并为n/2个组，组内单独排序；然后这些组再两两归并，生成n/4个组，组内再单独排序；以此类推，直到只剩下一个组为止。时间复杂度为$O(nlog_2n)$，实现方法有递归和非递归两种。  
首先要实现每一趟组内排序都要用到的**一次归并算法**。主要思想为**two pointers**。  

```cpp
void Merge(int r[], int left, int mid, int right)//合并两个有序序列
{//对序列r[left]~r[mid]和r[mid+1]~r[right]进行归并
    int i(left), j(mid+1),k(0);//two pointers为i和j，指向新序列的是k
    int* temp = new int[right-left+1];//临时数组存储合并的序列
    while(i <= mid && j <= right)
    {
        if(r[i] <= r[j]) temp[k++] = r[i++];
        else temp[k++] = r[j++];
    }
    while(i <= mid) temp[k++] = r[i++];
    while(j <= right) temp[k++] = r[j++];
    for(int i=left,k=0; i <= right; i++, k++)
    { r[i] = temp[k];}//将合并好的序列放回原序列r中去
    delete []temp;//释放内存
}
```

**递归版本：** 自顶向下的 **分治**法，简洁，但效率低  

```cpp
void MergeSort(int r[], int left, int right)
{
    if(left < right)//递归边界，待排序列只剩一个记录
    {//递归子式
        int mid = (left + right) / 2;
        MergeSort(r, left, mid);//递归，将左子区间归并排序
        MergeSort(r, mid+1, right);//递归，将右子区间归并排序
        Merge(r, left, mid, right);//将两个已排序的子区间归并
    }
}
```

**非递归版本：** 自底向上的方法，复杂，但效率高  
思路：  
（1）n个长度为1的有序序列，设定初始步长step=1  
（2）两两归并，得到[n/2]（向上取整）个长度为2的有序序列  
（3）再进行两两归并，得到[n/4]个长度为4的有序序列  
（4）···直到得到一个长度为n的有序序列为止  

```cpp
void MergeSort(int r[], int n)
{
    for(int step=1; step < n; step *= 2)//分组
    {//left+step=mid+1,是右子区间的第一个元素，它<n,保证最后一次合并有两个区间
        for(int left=0; left+step<n; left+=2*step)//对每一组内部进行一次归并排序
        {
            int mid = left + step - 1;  
            int right = left + 2*step -1;//左left~mid，右mid~right
            if(right > n-1) right = n-1;//保证右子区间别出界
                 Merge(r, left, mid, right);
        }
    }
}
```

## 2 散列(hash)

- 散列表（hash table）：采用散列技术将记录存储在一块连续的存储空间（这块存储空间称为散列表）中；
- 散列函数（hash function）：将关键码映射为散列表中适当存储位置的函数；
- 散列地址（hash address）：所得的存储位置；
- 冲突（collision）：两个不同的记录通过散列函数计算出同样的散列地址，要存放在同一个存储位置中。
- 同义词（synonym）：两个不同的关键码$k_1\not=k_2$，有$H(k_1)=H(k_2)$，$k_1和k_2$相对于H称作同义词。
- 堆积（mass）:处理冲突过程中出现的非同义词之间对同一个散列地址争夺的现象。会出现在线性探查法中。

**散列既是一种存储方法，也是一种查找方法。但是散列不是一种完整的存储结构**，因为它只通过记录的关键码来定位该记录，很难完整的表达记录之间的逻辑关系，**所以，散列主要是面向查找的存储结构。**

**散列过程：**  
（1）**存储记录时**，通过散列函数计算记录的散列地址，并按此地址来存储该记录；  
（2）**查找记录时**，通过同样的散列函数计算记录的散列地址，按此地址来访问记录。  

散列表一般**不适用于多个记录有相同关键码的情况，也不适用于范围查找**（因为散列查找是计算查找，而不是比较查找，所以不大可能找到最大啦、最小啦、某一范围啦之类的记录）。**最适用于：如果有的话，哪个记录的关键码等于待查值。**

**两个主要问题：**

- 散列函数的设计：原则要简单，函数值分布要均匀（简单和均匀本身就矛盾，要合理取舍）
- 冲突的处理

### 2.1 散列函数（hash function）

常见的散列函数|数学公式|性能和适用情形
:-:|:-:|:-:
直接定址法|$H(key)=a\times key + b$|简单均匀，要知道关键码的分布，且关键码集合不大而连续性好
除留余数法|$H(key)=key\  mod\  p$|简单常用，不需要知道关键码的分布
数字分析法|根据关键码各位数字的分布，取分布较均匀的若干位组成散列地址|要知道key的分布，且若干位分布较均匀
平方取中法|对关键码平方后，按hash大小，取中间的若干位作为散列地址|不需要知道key的分布，且key的位数不是很大
折叠法（将key分割为几部分，叠加取后几位作为散列地址）|移位折叠（单向折叠）和间界折叠（来回折叠）|不需要知道key的分布，key位数较多，且每一位都分布不均匀

### 2.2 冲突的处理

解决方法|hash类型|描述
-|-|-
开放定址法(open addressing)|闭散列表（事先估计定好容量）|有线性探查法、二次探查法和随机探查法三种
链地址法|开散列表（同义词字表的表长是动态变化的，无需事先确定表的容量）|将所有散列地址相同的记录（key为同义词的记录）存储在一个单链表中-称为同义词字表，在散列表中存储的是所有同义词字表的头指针

#### 2.2.1 线性探查法

发生冲突时，从冲突下一位置起，依次寻找空的散列地址（将冲突位置的hash值不断加1），如果检查过程超出了表长，那就回到表首位置继续循环（直到找到空的散列地址或所有位置已满）。

#### 2.2.2 二次探查法

为了尽可能避免堆积现象，发生冲突时，按以下顺序来寻找空的散列地址：$H(k)+1^2$、$H(k)-1^2$、$H(k)+2^2$、$H(k)-2^2$、...同样地，过程中如果探查超出了表长，那就对表长取模

#### 2.2.3 随机探查法

当发生冲突时，探查的下一个散列地址的位移量是一个随机数列。

#### 2.2.3 链地址法

## 3 递归

### 3.1 分治(divide and conquer)

分而治之，将原问题若干个子问题，分别解决这些子问题，最后合并子问题的解，从而得到原问题的解。 **分治即可通过递归的手段去实现，也可以通过非递归的手段去实现。**  
**主要步骤：**  
（1）分解：原问题分解为子问题  
（2）解决：递归求解所有子问题  
（3）合并：将子问题的解合并为原问题的解  

### 3.2 递归

一句话“**函数调用自己**”，本身是一种栈操作，每一次递归保存了当前层的所有信息，这样就容易导致栈溢出。  
**两部分构成：**  
（1）递归边界 ：分解的尽头  
（2）递归式 ：将原问题分解为若干子问题的手段  

## 4 贪心

贪心法是求解一类最优化问题的方法，它总是考虑当前状态下的**局部最优（或较优）**的策略，来使全局的结果达到最优（或较优）。总之从**局部最优到全局最优**。  
贪心算法适用的问题一定满足**最优子结构性质**，即一个问题的最优解可以由它的子问题的最优解有效地构造出来。

## 5 二分

### 5.1 二分查找

二分查找就是**折半查找（binary search）**，是基于有序序列的查找算法。属于静态查找。  
实现手段有递归手段和非递归手段，算法时间复杂度为$O(log_2n)$。  
折半查找适用的问题有木棒切割问题和装水问题，即对题目所要求的东西进行二分，来找一个满足所需条件的解。

### 5.2 快速幂

#### 5.2.1 快速幂的递归实现

快速幂基于二分的思想（因此又称二分幂），结合递归，实现过程如下：  
（1）如果b是奇数，那么有$a^b=a*a^{b-1}$  
（2）如果b是偶数，那么有$a^b=a^{b/2}*a^{b/2}$  
这样，在经过$log_2b$次数的转换后，就可以把b变为0，时间复杂度为$O(log_2b)$。  

```cpp
typedef long long LL;
LL BinaryPow(LL a, LL b)
{
    if(b == 0) return 1;//递归边界,如果b=0,那么a^0=1
    //以下为递归子式
    if(b % 2 == 1) return a * BinaryPow(a, b-1);
    else
    {
        LL temp = BinaryPow(a, b/2);
        return temp * temp;
    }
}
```

#### 5.2.3 快速幂的迭代实现

对于$a^b$，可以把b写成二进制，那么b就可以写成若干二次幂之和。比如：  
$a^{13}=a^{1101B}=a^{2^3+2^2+2^0}=a^8+a^4+a^1$  
所以可以把$a^b$表示为$a^{2^k}、... 、a^{2^2}、a^{2^1}$中若干项的乘积，其中如果b的二进制的i号位为1，那么项$a^{2^i}$就被选中。  
大致思路为：  
令i从0到k枚举b的二进制每一位，如果当前位为1，那么累积$a^{2^i}$。  
（1）初始令ans=1  
（2）判断b是否为奇数（二进制末尾位是否为1），是的话，令ans乘上a的值  
（3）令a平方，并将b右移一位（除以2）  
（4）只要b大于0，就返回(2)  

```cpp
typedef long long LL;
LL BinaryPow(LL a, LL b)
{
    LL ans = 1;
    while(b > 0)
    {
        if(b & 1) ans = a * ans;
        a = a * a;
        b >>= 1;
    }
    return ans;
}
```

## 6 two pointers

**two pointers**是一种重要的编程思想，更加像是一种编程技巧。  
比如：有一个递增的正整数序列和一个正整数m，求序列中两个不同数之和为m的情况  
如果使用暴力法进行枚举，需要二重循环，算法复杂度为$O(n^2)$，但是如果使用two pointers思想，则算法复杂度仅为$O(n)$  

```cpp
while(i < j)//i,j分别指向头尾，初始化为0，n-1；i只能增，j只能减，直到i>=j
{
    if(a[i] + a[j] == m)//刚好为m，那么同时i增和j减
    {
        cout << a[i] << "+" << a[j] <<endl;
        i++;
        j--;
    }
    else if(a[i] + a[j] < m) i++;//小于，只能i增，和才会增
    else j--;//大于，只能j减，和才会减
}
```

再如**序列合并问题**，有两个递增序列A和B，将它们合并为一个递增数列C。  
思路：设置两个下标i和j分别指向两个序列的首元素，然后根据A[i]与B[j]的大小来决定哪一个放入序列C。

```cpp
int merge(int A[], int B[], int C[], int n, int m)
{
    int i(0),j(0),index(0);
    while(i < n && j < m)//比较部分，取小的放入C
    {//注意i++是先用再加，所以依然是从0位开始的，没问题
        if(A[i] <= B[j]) C[index++] = A[i++];
        else C[index++] = B[j++];
    }//某一个序列放入完毕，剩下的另一个序列的剩余部分就可以直接放入C
    while(i < n) C[index++] = A[i++];
    while(j < m) C[index++] = B[j++];
    return index;//返回序列C的长度
}
```

**two pointers思想**就是利用问题本身与序列的特性，使用两个下标i、jd对序列进行扫描（同向和反向均可），以较低的复杂度（一般是$O(n)$）解决问题。  

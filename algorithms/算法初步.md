# 算法初步

<!-- TOC -->

- [算法初步](#算法初步)
    - [1  排序](#1--排序)
        - [1.1 选择排序(selection sort)](#11-选择排序selection-sort)
            - [1.1.1 简单选择排序(simple selection sort)](#111-简单选择排序simple-selection-sort)
            - [1.1.2 堆排序(heap sort)](#112-堆排序heap-sort)
        - [1.2 交换排序](#12-交换排序)
            - [1.2.1 冒泡排序(bubble sort)](#121-冒泡排序bubble-sort)
            - [1.2.2 快速排序(quick sort)](#122-快速排序quick-sort)
        - [1.3 插入排序(insertion sort)](#13-插入排序insertion-sort)
            - [1.3.1 直接插入排序(straight insertion sort)](#131-直接插入排序straight-insertion-sort)
            - [1.3.2 希尔排序(shell sort)](#132-希尔排序shell-sort)
        - [1.4 归并排序(merge sort)](#14-归并排序merge-sort)
        - [1.5 分配排序](#15-分配排序)
            - [1.5.1 桶排序(bucket sort)](#151-桶排序bucket-sort)
            - [1.5.2 基数排序](#152-基数排序)
        - [1.6 计数排序(count sort)](#16-计数排序count-sort)
    - [2 散列(hash)](#2-散列hash)
        - [2.1 散列函数（hash function）](#21-散列函数hash-function)
        - [2.2 冲突的处理](#22-冲突的处理)
            - [2.2.1 线性探查法](#221-线性探查法)
            - [2.2.2 二次探查法](#222-二次探查法)
            - [2.2.3 随机探查法](#223-随机探查法)
            - [2.2.3 链地址法](#223-链地址法)
    - [3 递归](#3-递归)
        - [3.1 分治(divide and conquer)](#31-分治divide-and-conquer)
        - [3.2 递归](#32-递归)
    - [4 贪心](#4-贪心)
    - [5 二分](#5-二分)
        - [5.1 二分查找](#51-二分查找)
        - [5.2 快速幂](#52-快速幂)
            - [5.2.1 快速幂的递归实现](#521-快速幂的递归实现)
            - [5.2.3 快速幂的迭代实现](#523-快速幂的迭代实现)
    - [6 two pointers](#6-two-pointers)

<!-- /TOC -->

## 1  排序

- 所谓排序指的是将一个记录序列重新排列成一个按关键码有序的序列.  
- 排序过程一般由两步组成:  
 i. 比较---关键码之间的比较  
 ii.移动---记录从一个位置移动到另一个位置  

**术语：**  

- 稳定排序：a==b，排序前a在b前，排序后a一定还在b前
- 非稳定排序：a==b，排序前a在b前，排序后a不一定还在b前
- 原地排序：排序过程中不用申请多余的存储空间  
- 非原地排序：排序过程中需要额外的存储空间来辅助
- 时间复杂度：执行完一个算法所消耗的时间
- 空间复杂度：执行完一个算法所需的内存大小

- 几大排序思想:

排序思想|排序名称
:-:|:-:
插入排序|直接插入排序+希尔排序
交换排序|冒泡排序+快速排序
选择排序|简单选择排序+堆排序
归并排序|非递归+递归
分配排序|桶式排序+基数排序

- 快速排序的时间复杂度是$O(nlogn)$，实际上，快排的最坏时间复杂度是$O(n^2)$，而堆排序和归并排序的时间复杂度都稳定在$O(nlogn)$

### 1.1 选择排序(selection sort)

- **主要思想:** 每趟排序,在当前无序序列中选出关键码最小的记录,添加到有序序列中.
- 特点:记录移动次数较少

#### 1.1.1 简单选择排序(simple selection sort)

**过程:**  
(1) 将整个记录序列分为有序区和无序区,有序区初始化为空,无序区初始化为整个记录序列  
(2) 在无序区中选择关键码最小的记录,将它与无序区中的第一个记录交换.使得有序区扩展了一个记录,无序区减少了一个记录.  
(3) 不断重复(2),直至无序区只剩下一个记录为止.  

```cpp
void SelectSort(int r[], int n)
{
    for(int i=0; i<n-1; i++)//无序区起始位置
    {
        int min = i;
        for(int j = i+1; j<n; j++)//找到无序区中最小的元素
        {
            if(r[min] > r[j]) min = j;
        }
        int temp = r[i];//将无序区最小元素与第一个元素交换
        r[i] = r[min];
        r[min] = temp;
    }
}

// 记忆
void selectSort(vector<int> &q) {
    for(int i=0; i<q.size(); i++) {
        int min = i;;
        for(int j=i+1; j<q.size(); j++)
            if(q[min] > q[j]) min = j;
        if(min != i) swap(q[min], q[i]);
    }
}
```

**分析:**  

- 时间复杂度:$O(n^2)$
- 空间复杂度：$O(1)$，只需要一个用来作为记录交换的暂存单元
- 非稳定排序
- 原地排序

#### 1.1.2 堆排序(heap sort)  

对simple selection sort进行改进:在无序区中选出最小关键码的同时,也找出较小的关键码,减少了后面的比较次数,从而提高整体效率.  
**堆**的特点就是**堆顶元素一个是最值**，大根堆是指结点大于等于其左右孩子结点，小根堆是指结点小于等于其左右孩子结点  
**思想：** 把堆顶元素与最后一个元素交换，再把堆中剩余的元素再次构成一个大根堆，然后再把堆顶元素与最后第二个元素交换···如此往复下去，直到堆中只剩下一个元素，此时的序列就是有序的了。  
**筛选法调整堆为大根堆：**

```cpp
void Sift(int r[], int parent, int length)
{
    int child = 2*parent + 1;//child初始指向parent的左孩子，序号从0开始
    while(child < length)
    {
        if(child<length && r[child]<r[child+1]) child++;//使得child指向大孩子
        //保证parent指向的是最大值
        if(r[parent]>r[child]) break;
        else
        {//parent小于孩子时，交换parent和child
            int temp = r[parent];
            r[parent] = r[child];
            r[child] = temp;
            parent = child;
            child = 2*parent +1;
        }
    }
}
```

**堆排序：**

```cpp
void HeapSort(int r[], int length)
{
    for(int i = length/2 - 1; i>=0; i--)//构建最大堆
        Sift(r, i, length);
    for(int i=length-1; i>=1; i--)
    {//反复将堆顶元素与最后一个元素交换
        int temp = r[0];
        r[0] = r[i];
        r[i] = temp;
        Sift(r, 0, i);//打乱的堆进行调整，恢复最大堆
    }
}
```

- 时间复杂度：$O(nlogn)$
- 空间复杂度：$O(1)$
- 非稳定排序
- 原地排序

### 1.2 交换排序

**主要思想：** 在待排序列中选两个记录，对他们关键码进行比较，如果反序则交换它们位置  
交换排序，顾名思义，一定会需要交换操作，所以先完成两数交换函数：  

```cpp
void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}
```

#### 1.2.1 冒泡排序(bubble sort)

**思路：** 两两比较相邻记录的关键码，反序则交换，直到没有反序为止  

```cpp
void BubbleSort(int r[], int n)
{
    int exchange = n-1;//第一趟排序是整个序列
    while(exchange != 0)//排序结束的条件：某一趟排序过程中没有进行记录交换
    {
        int bound = exchange;//本趟排序的边界
        exchange = 0;//重置交换标志，以便确定后面是否发生交换
        for(int i=0; i < bound; i++)//遍历
        {
            if(r[i] > r[i+1])//元素交换
            {
                swap(r[i], r[i+1]);
                exchang = i;//记录交换产生的位置，把该趟最后的exchange作为下一趟的边界
            }
        }
    }
}
// 记忆这个版本
// 优化：如果某一趟冒泡的过程中，没有发生交换，说明已经有序了
// 而且整个排序过程中的swap次数是可以求出来的，就是逆序对的个数（可以用归并排序求）
void bubble_sort(vector<int> &q) {
    for(int i=q.size()-1; i>0; i--) {
        bool flag = false;
        for(int j=0; j+1<=i; j++)
            if(q[j] > q[j+1]) flag = true, swap(q[j], q[j+1]);
        if(!flag) break;
    }

}
// 还可以再次优化，每趟都以上一次最后交换的位置作为边界
void bubbleSort(vector<int> &q) {
    int exchange = q.size()-1;
    while(exchange) {
        int bound = exchange;
        exchange = 0;
        for(int i=0; i+1<=bound; i++)
            if(q[i] > q[i+1]) exchange = i, swap(q[i], q[i+1]);
    }
}
```

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$
- 稳定排序
- 原地排序

#### 1.2.2 快速排序(quick sort)

**主要思路**：是对冒泡排序的一种改进。又称**分区交换排序**，首先选一个轴值povit(比较的基准)，将待排序列划分为两部分，左侧均不大于povit，右侧均不小于povit；然后分别对左右两侧重复上面操作，直到整个序列有序。  

**一次划分算法：**基于**tow pointers**思想：  
直接选取第一个元素为povit,重复下面过程直到left=right，便确定了排序后该povit处于数组的位置是left
（1）右侧扫描(right--)，直到r[left]>r[right]  
（2）如果存在划分区间，则swap(r[left], r[right]),并left++  
（3）左侧扫描(left++)，直到r[left]>r[right]  
（4）如果存在划分区间，则swap(r[left], r[right])，并right--  

```cpp
int Partition(int r[], int left, int right)
{
    while(left < right)
    {
        while(left < right && r[left] <= r[right]) right--;//起步povit就是第一个元素，开启右侧扫描
        if(left < right)    //将较小记录交换到前面
            swap(r[left++], r[right]);//povit就在右边了，开启左侧扫描
        while(left < right && r[left] <= r[right]) left++;//左侧扫描
        if(left < right)    //将较大记录交换到后面
            swap(r[right--], r[left]);//povit回到左边，开启右侧扫描
    }
    return left;//轴值的最终记录，left=right

}
```

快速排序算法借助于递归来实现，若待排序列中只有一个记录，则递归结束，否则进行一次划分后，再分别对划分得到的两个子序列进行快速排序（即递归处理）.  

```cpp
void QuickSort(int r[], int left, int right)
{
    if(left < right)//递归边界
    {
        int povit = Partition(r, left, right);//一次划分
        QuickSort(r, left, povit-1);//递归左子区间
        QuickSort(r, povit+1, right);//递归右子区间
    }
}
```

- 时间复杂度为$O(nlogn)$
- 空间复杂度:$O(logn)$
- 非稳定排序
- 原地排序

### 1.3 插入排序(insertion sort)  

- **主要思想:**  每次将一个无序区的记录按其关键码的大小插入到有序序列中.

#### 1.3.1 直接插入排序(straight insertion sort)

**过程:**  
(1) 划分有序区和无序区,有序区初始化为待排记录序列的第一个记录,无序区初始化为所有剩余记录  
(2) 将无序区的第一个记录插入到有序区的合适位置,使得有序区增加一个记录,无序区减少一个记录  
(3) 重复执行(2)直到无序区没有记录  

```c++
void InsertSort(int r[], int length)
{
    for(int i=1; i<length; i++)
    {
        int temp = r[i];//暂存无序区的第一个元素
        int j;
        for(j=i-1; j>=0 && temp<r[j]; j--)//在有序区查找temp应该插入的位置
        {
            r[j+1] = r[j];//比temp大的元素要整体后移一位给temp让出位置
        }
        r[j+1] = temp;//r[j]<=temp<r[j+2]
    }
}

// 记忆此版本
// 打扑克，在有序区插入正确插入
void insertSort(vector<int> &q) {
    for(int i = 1; i < q.size(); i ++)
    {
        int t = q[i], j;
        for(j = i-1; j >= 0; j--)
        {
            if(q[j] > t) q[j+1] = q[j];
            else break;
        }
        q[j+1] = t;
    }
}
```

**分析:**  

- 时间复杂度:$O(n^2)$
- 空间复杂度：$O(1)$，只需要一个记录的辅助空间,用来作为待插入记录的暂存单元(不至于因记录的后移而丢失R[i]的内容),和查找记录的插入过程中的哨兵
- 稳定排序
- 原地排序
- 待排序列基本有序时,才是最佳排序方法.

#### 1.3.2 希尔排序(shell sort)  

对straight insertion sort进行改进:由于直接插入排序算法简单,则在待排序记录个数较少时效率也高.  
**主要思想:**  先将整个待排记录序列分割成若干个子序列,在子序列内分别进行直接插入排序,待整个序列基本有序时,再对全体记录进行一次直接插入排序。整体就是在插入排序的基础之上加一个控制增量进行分组的循环  
**注意：** 对各个分组进行插入排序时，并不是先把一个组排完了再来排下一组，而是轮流对每个组进行排序  

```cpp
void ShellSort(int r[], int length)
{
    for(int step=length/2; step>=1; step=step/2)//间隔为step，分组插入排序
    {
        for(int i=step; i<length; i++)//0~(step-1)分别是各组的第一个元素，不用排
        {//对step~length-1，分别在各自组中进行插入排序
            int temp = r[i];//暂存被插入元素
            int index = i - step;//在组中，倒着找应该插入的位置
            for( ; index>=0 && temp<r[index]; index-=step)
            {//比temp大的元素要整体后移一位给temp让出位置
                r[index+step] = r[index];
            }
            r[index+step] = temp;//找到的位置插入
        }
    }
}
```

- 时间复杂度第一个突破$O(n^2)$的排序
- 时间复杂度：与具体的增量序列有关，$O(nlogn)$~$O(n^2)$
- 空间复杂度：$O(1)$
- 非稳定排序
- 原地排序

### 1.4 归并排序(merge sort)

**主要思想：** 将若干个有序序列逐步归并，最终归并为一个有序序列。  
最简单的就是**二路归并排序(2-way merge sort)**：将序列两两分组进行归并，第一次归并为n/2个组，组内单独排序；然后这些组再两两归并，生成n/4个组，组内再单独排序；以此类推，直到只剩下一个组为止。时间复杂度为$O(nlog_2n)$，实现方法有递归和非递归两种。  
首先要实现每一趟组内排序都要用到的**一次归并算法**。主要思想为**two pointers**。  

```cpp
void Merge(int r[], int left, int mid, int right)//合并两个有序序列
{//对序列r[left]~r[mid]和r[mid+1]~r[right]进行归并
    int i(left), j(mid+1),k(0);//two pointers为i和j，指向新序列的是k
    int* temp = new int[right-left+1];//临时数组存储合并的序列
    while(i <= mid && j <= right)
    {
        if(r[i] <= r[j]) temp[k++] = r[i++];
        else temp[k++] = r[j++];
    }
    while(i <= mid) temp[k++] = r[i++];
    while(j <= right) temp[k++] = r[j++];
    for(int i=left,k=0; i <= right; i++, k++)
    { r[i] = temp[k];}//将合并好的序列放回原序列r中去
    delete []temp;//释放内存
}
```

**递归版本：** 自顶向下的 **分治**法，简洁，但效率低  

```cpp
void MergeSort(int r[], int left, int right)
{
    if(left < right)//递归边界，待排序列只剩一个记录
    {//递归子式
        int mid = (left + right) / 2;
        MergeSort(r, left, mid);//递归，将左子区间归并排序
        MergeSort(r, mid+1, right);//递归，将右子区间归并排序
        Merge(r, left, mid, right);//将两个已排序的子区间归并
    }
}
```

**非递归版本：** 自底向上的方法，复杂，但效率高  
思路：  
（1）n个长度为1的有序序列，设定初始步长step=1  
（2）两两归并，得到[n/2]（向上取整）个长度为2的有序序列  
（3）再进行两两归并，得到[n/4]个长度为4的有序序列  
（4）···直到得到一个长度为n的有序序列为止  

```cpp
void MergeSort(int r[], int n)
{
    for(int step=1; step < n; step *= 2)//分组
    {//left+step=mid+1,是右子区间的第一个元素，它<n,保证最后一次合并有两个区间
        for(int left=0; left+step<n; left+=2*step)//归并的两组序列为[left, left+step-1] [left+step, left+2*step-1]
        {
            int mid = left + step - 1;  
            int right = left + 2*step -1;//左left~mid，右mid~right
            if(right > n-1) right = n-1;//保证右子区间别出界
            Merge(r, left, mid, right);
        }
    }
}
```

- 时间复杂度：$O(nlogn)$
- 空间复杂度：$O(n)$
- 稳定排序
- 非原地排序

### 1.5 分配排序

前面的排序都是基于比较（关键码的比较）的排序，而分配排序是基于**分配**和**收集**的排序方法。  
**基本思想：** 先将待排序列分配至不同的桶里，然后再把各桶中的记录依次收集到一起  

#### 1.5.1 桶排序(bucket sort)

**思想：** 把最大值和最小值之间的数进行瓜分，例如分成10区间（对应着10个桶），把元素放到对应区间的桶中去，再对每个桶中的数进行排序（可以采用归并排序、快排之类的方法）,最后再汇总  

```cpp
void BucketSort(int r[], int length)
{
    int min = r[0];
    int max = r[0];
    for(int i=0; i<length; i++)
    {
        if(min > r[i]) min=r[i];
        if(max < r[i]) max=r[i];
    }
    int  d = max - min;
    int bucketNum = d/5 + 1;
}
// 桶排序是计数排序的升级版，把数据范围划分为几个桶，桶之间是天然有序的
// 再在各个桶内使用其他排序方法进行排序
// 数据范围大，且分布比较均匀
```

- 时间复杂度：$O(n+k)$，k表示桶的个数
- 空间复杂度：$O(n+k)$
- 稳定排序
- 非原地排序

#### 1.5.2 基数排序

**思想：** 先以个位数的大小来对数据进行排序，接着以十位数的大小来多数进行排序，接着以百位数的大小···，排到最后就是有序的了。不过，它在以某位数进行排序的时候，是用“桶”来排序的（0~9共十个桶，以某位数排序的时候，就把相同数值的数放进同一个桶里，之后再把桶里的数按照0号到9号桶的顺序取出来）

```cpp
// 取x的第i位上的数字,从第0位开始
int get(int x, int i) {
    while(i--) x /= 10;
    return x % 10;
}
// 基数排序,假设数据范围为[0~999]
void radixSort(vector<int> &q) {
    vector<vector<int>> cnt(10); // 数字0~9对应十个桶
    // 个、十、百位
    for(int i=0; i<3; i++) {
        for(int j=0; j<10; j++) cnt[j].clear(); // 清空
        // 把元素放进9个桶里面去
        for(int j=0; j<q.size(); j++)
            cnt[get(q[j], i)].push_back(q[j]);
        // 再把每个桶里面的元素取出来放回去
        for(int j=0, k=0; j<10; j++)
            for(int x : cnt[j]) q[k++] = x;
    }
}

// 计数、桶排、基数排序都是基于桶的一种实现方式
// 计数排序每个数就是一个数桶
// 基数是按数的各个位来进行排序，需要用到除法和取模运算，所以运行起来对性能影响较大
```

- 时间复杂度：$O(nk)$，k表示桶的个数
- 空间复杂度：$O(n+k)$
- 稳定排序
- 非原地排序

### 1.6 计数排序(count sort)

- 适用于最大值和最小值的差值不是很大的排序

**思想：** 创建一个临时数组用于统计待排序列中每个数字出现的次数，把待排序列元素作为数组的下标，如temp[i]=m（表示元素i出现了m次），然后再把数组中统计的数据从小到大汇总起来。  

```cpp
// 数的取值范围不大时，直接统计每个数的个数
// 比如数的范围在[0, 100]，直接开辟一个cnt[101]的辅助数组进行统计
// 只需遍历一遍数组就可以了，线性复杂度，空间换时间
// 计数排序一个典型的应用就是后缀数组
void countSort(vector<int> &q) {
    vector<int> cnt(101);
    for(int x : q) cnt[x]++;
    for(int i=0, j=0; i<cnt.size(); i++) {
        while(cnt[i]>0) {
            q[j++] = i, cnt[i]--;
        }
    }
}
```

- 时间复杂度：$O(n+k)$，k表示临时数组的大小
- 空间复杂度：$O(k)$
- 稳定排序
- 非原地排序

## 2 散列(hash)

- 散列表（hash table）：采用散列技术将记录存储在一块连续的存储空间（这块存储空间称为散列表）中；
- 散列函数（hash function）：将关键码映射为散列表中适当存储位置的函数；
- 散列地址（hash address）：所得的存储位置；
- 冲突（collision）：两个不同的记录通过散列函数计算出同样的散列地址，要存放在同一个存储位置中。
- 同义词（synonym）：两个不同的关键码$k_1\not=k_2$，有$H(k_1)=H(k_2)$，$k_1和k_2$相对于H称作同义词。
- 堆积（mass）:处理冲突过程中出现的非同义词之间对同一个散列地址争夺的现象。会出现在线性探查法中。

**散列既是一种存储方法，也是一种查找方法。但是散列不是一种完整的存储结构**，因为它只通过记录的关键码来定位该记录，很难完整的表达记录之间的逻辑关系，**所以，散列主要是面向查找的存储结构。**

**散列过程：**  
（1）**存储记录时**，通过散列函数计算记录的散列地址，并按此地址来存储该记录；  
（2）**查找记录时**，通过同样的散列函数计算记录的散列地址，按此地址来访问记录。  

散列表一般**不适用于多个记录有相同关键码的情况，也不适用于范围查找**（因为散列查找是计算查找，而不是比较查找，所以不大可能找到最大啦、最小啦、某一范围啦之类的记录）。**最适用于：如果有的话，哪个记录的关键码等于待查值。**

**两个主要问题：**

- 散列函数的设计：原则要简单，函数值分布要均匀（简单和均匀本身就矛盾，要合理取舍）
- 冲突的处理

### 2.1 散列函数（hash function）

常见的散列函数|数学公式|性能和适用情形
:-:|:-:|:-:
直接定址法|$H(key)=a\times key + b$|简单均匀，要知道关键码的分布，且关键码集合不大而连续性好
除留余数法|$H(key)=key\  mod\  p$|简单常用，不需要知道关键码的分布
数字分析法|根据关键码各位数字的分布，取分布较均匀的若干位组成散列地址|要知道key的分布，且若干位分布较均匀
平方取中法|对关键码平方后，按hash大小，取中间的若干位作为散列地址|不需要知道key的分布，且key的位数不是很大
折叠法（将key分割为几部分，叠加取后几位作为散列地址）|移位折叠（单向折叠）和间界折叠（来回折叠）|不需要知道key的分布，key位数较多，且每一位都分布不均匀

### 2.2 冲突的处理

解决方法|hash类型|描述
-|-|-
开放定址法(open addressing)|闭散列表（事先估计定好容量）|有线性探查法、二次探查法和随机探查法三种
链地址法|开散列表（同义词字表的表长是动态变化的，无需事先确定表的容量）|将所有散列地址相同的记录（key为同义词的记录）存储在一个单链表中-称为同义词字表，在散列表中存储的是所有同义词字表的头指针

#### 2.2.1 线性探查法

发生冲突时，从冲突下一位置起，依次寻找空的散列地址（将冲突位置的hash值不断加1），如果检查过程超出了表长，那就回到表首位置继续循环（直到找到空的散列地址或所有位置已满）。

#### 2.2.2 二次探查法

为了尽可能避免堆积现象，发生冲突时，按以下顺序来寻找空的散列地址：$H(k)+1^2$、$H(k)-1^2$、$H(k)+2^2$、$H(k)-2^2$、...同样地，过程中如果探查超出了表长，那就对表长取模

#### 2.2.3 随机探查法

当发生冲突时，探查的下一个散列地址的位移量是一个随机数列。

#### 2.2.3 链地址法

## 3 递归

### 3.1 分治(divide and conquer)

分而治之，将原问题若干个子问题，分别解决这些子问题，最后合并子问题的解，从而得到原问题的解。 **分治即可通过递归的手段去实现，也可以通过非递归的手段去实现。**  
**主要步骤：**  
（1）分解：原问题分解为子问题  
（2）解决：递归求解所有子问题  
（3）合并：将子问题的解合并为原问题的解  

### 3.2 递归

一句话“**函数调用自己**”，本身是一种栈操作，每一次递归保存了当前层的所有信息，这样就容易导致栈溢出。  
**两部分构成：**  
（1）递归边界 ：分解的尽头  
（2）递归式 ：将原问题分解为若干子问题的手段  

**适用情况：** 问题可以分解成**具有相同解决思路**的子问题，子问题又可以分解为**具有相同解决思路**的子子问题，直至最终的子问题无法分解

**递归的优化：**  

- 考虑是否重复计算，可以把已经计算过的值用hash表保存起来（**空间换时间**），以后计算的时候，可以先判断一下之前是否计算过，如果计算过，直接从hash表中取出来就可以了，没有计算过的话，再递归计算
- 考虑是否可以采用自底向上（称为**递推**），应该是迭代

## 4 贪心

贪心法是求解一类最优化问题的方法，它总是考虑当前状态下的**局部最优（或较优）**的策略，来使全局的结果达到最优（或较优）。总之从**局部最优到全局最优**。  
贪心算法适用的问题一定满足**最优子结构性质**，即一个问题的最优解可以由它的子问题的最优解有效地构造出来。

## 5 二分

### 5.1 二分查找

二分查找就是**折半查找（binary search）**，是基于有序序列的查找算法。属于静态查找。  
实现手段有递归手段和非递归手段，算法时间复杂度为$O(log_2n)$。  
折半查找适用的问题有木棒切割问题和装水问题，即对题目所要求的东西进行二分，来找一个满足所需条件的解。

```cpp
template<class T>
int BinarySearch(std::vector<T> vec, T target)
{
    int left(0), right(vec.size()-1);   //在[left, right]中查找
    while(left <= right)
    {
        int mid = left + (right-left)/2;
        if(target == vec[mid]) return mid;
        if(target < vec[mid]) right = mid - 1;
        else
            left = mid + 1;
    }
    return -1;
}
```

### 5.2 快速幂

#### 5.2.1 快速幂的递归实现

快速幂基于二分的思想（因此又称二分幂），结合递归，实现过程如下：  
（1）如果b是奇数，那么有$a^b=a*a^{b-1}$  
（2）如果b是偶数，那么有$a^b=a^{b/2}*a^{b/2}$  
这样，在经过$log_2b$次数的转换后，就可以把b变为0，时间复杂度为$O(log_2b)$。  

```cpp
typedef long long LL;
LL BinaryPow(LL a, LL b)
{
    if(b == 0) return 1;//递归边界,如果b=0,那么a^0=1
    //以下为递归子式
    if(b % 2 == 1) return a * BinaryPow(a, b-1);
    else
    {
        LL temp = BinaryPow(a, b/2);
        return temp * temp;
    }
}
```

#### 5.2.3 快速幂的迭代实现

对于$a^b$，可以把b写成二进制，那么b就可以写成若干二次幂之和。比如：  
$a^{13}=a^{1101B}=a^{2^3+2^2+2^0}=a^8*a^4*a^1$  
所以可以把$a^b$表示为$a^{2^k}、... 、a^{2^2}、a^{2^1}$中若干项的乘积，其中如果b的二进制的i号位为1，那么项$a^{2^i}$就被选中。  
大致思路为：  
令i从0到k枚举b的二进制每一位，如果当前位为1，那么累积$a^{2^i}$。  
（1）初始令ans=1  
（2）判断b是否为奇数（二进制末尾位是否为1），是的话，令ans乘上a的值  
（3）令a平方，并将b右移一位（除以2）  
（4）只要b大于0，就返回(2)  

```cpp
typedef long long LL;
LL BinaryPow(LL a, LL b)
{
    LL ans = 1;
    while(b > 0)
    {
        if(b & 1) ans = a * ans;
        a *= a;
        b >>= 1;
    }
    return ans;
}
```

## 6 two pointers

**two pointers**是一种重要的编程思想，更加像是一种编程技巧。  
比如：有一个递增的正整数序列和一个正整数m，求序列中两个不同数之和为m的情况  
如果使用暴力法进行枚举，需要二重循环，算法复杂度为$O(n^2)$，但是如果使用two pointers思想，则算法复杂度仅为$O(n)$  

```cpp
while(i < j)//i,j分别指向头尾，初始化为0，n-1；i只能增，j只能减，直到i>=j
{
    if(a[i] + a[j] == m)//刚好为m，那么同时i增和j减
    {
        cout << a[i] << "+" << a[j] <<endl;
        i++;
        j--;
    }
    else if(a[i] + a[j] < m) i++;//小于，只能i增，和才会增
    else j--;//大于，只能j减，和才会减
}
```

再如**序列合并问题**，有两个递增序列A和B，将它们合并为一个递增数列C。  
思路：设置两个下标i和j分别指向两个序列的首元素，然后根据A[i]与B[j]的大小来决定哪一个放入序列C。

```cpp
int merge(int A[], int B[], int C[], int n, int m)
{
    int i(0),j(0),index(0);
    while(i < n && j < m)//比较部分，取小的放入C
    {//注意i++是先用再加，所以依然是从0位开始的，没问题
        if(A[i] <= B[j]) C[index++] = A[i++];
        else C[index++] = B[j++];
    }//某一个序列放入完毕，剩下的另一个序列的剩余部分就可以直接放入C
    while(i < n) C[index++] = A[i++];
    while(j < m) C[index++] = B[j++];
    return index;//返回序列C的长度
}
```

**two pointers思想**就是利用问题本身与序列的特性，使用两个下标i、jd对序列进行扫描（同向和反向均可），以较低的复杂度（一般是$O(n)$）解决问题。  

# 位运算

<!-- TOC -->

- [位运算](#位运算)
    - [1 位运算基础](#1-位运算基础)
    - [2 位运算技巧](#2-位运算技巧)
    - [3 例题](#3-例题)
        - [3.1 只出现一次的数字](#31-只出现一次的数字)

<!-- /TOC -->

## 1 位运算基础

|符号|描述|运算规则
|-|-|-|
|&|与|两个位都为1时，结果才为1|
|\||或|两个位都为0时，结果才为0|
|^|异或|两个位相异才为1|
|~|取反|0变1，1变0|
|<<|左移|各二进制位全部左移若干位<br>高位丢弃，低位补0|
|>>|右移|各二进制位全部左移若干位<br>无符号数，高位补0<br>有符号数，补符号位（算术右移下）或补0（逻辑右移下）|

## 2 位运算技巧

1. 使用`x&1 == 1`判断奇偶（一些编译器会把用%判断奇偶的代码自动优化成位运算）
2. 不使用第三个数，交换两个数

    ```cpp
    x = x^y;
    y = x^y;
    x = x^y;
    ```

3. 两个相同的数异或的结果是0，一个数和0异或的结果是它本身，异或操作满足交换律和结合律（找数可以用异或）

    ```cpp
    x^x == 0;
    x^0 == x;
    a^b^a == (a^a)^b == b
    ```

4. `x&(x-1)`可以把x最右边的1置0。（检测2的幂，二进制数中1的个数，一个数变成另一个数其中改变了几个bit位）
5. **异或**可以作为**无进位加法**来使用，**与**操作可以用来**获取进位**
6. `x+(~x) == -1`,x取反再与x相加，相当于把所有二进制位置1，其十进制结果为-1
7. 对于`int32`而言，使用`n>>31`取得n的正负号，通过`n^(n>>31) - (n>>31)`可以取得n的绝对值
    - n>=0时，`n>>31`的所有位都为0，即`n>>31 == 0`,所以`n^(n>>31) == n`，显然`n^(n>>31) - (n>>31) == n`
    - n<0时，`n>>31`的所有位都为1(就是十进制的-1)，所以`n^(n>>31) == ~n`,进而`n^(n>>31) - (n>>31) == ~n+1`表示对n各位（包括符号位，负数符号位取反不就为正数了）取反再加1（除了符号位，取反加1不就表示数的大小了么，再结合符号位取反了，最后就是绝对值了）
8. 使用`x^y >= 0`判断两数的符号是否相同

## 3 例题

### 3.1 只出现一次的数字

- 题：非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现三次，找出该元素

1. 法一：hashmap

    ```cpp
    int SingleNum(vector<int> nums)
    {
        unordered_map<int, int> hm;
        for(auto i : nums) hm[i]++;
        for(auto j : nums)
        {
            if(hm[j] == 1) return j;
        }
        return 0;
    }
    ```

2. 法二：数学法

   - 思路：把原数组去重（每个数只留一个），求和后乘以3，再减去原数组所有元素之和，得到的结果就是要找的元素的2倍

   ```cpp
   int SingleNum(vector<int> nums)
   {
       set<int> myset;
       int sum0(0), sum1(0);
       for(auto i : nums)
       {
           myset.insert(i);
           sum0 += i;//原数组求和
       }
       for(auto j : myset) sum1 += j;//去重后求和
       return (3*sum1 - sum0) / 2;
   }
    ```

3. 法三：位运算

    - 思路：统计二进制每一位上1的个数，只要是3的倍数就置0
    - 通法，可以记题中数字重复的次数为n

    ```cpp
    int SingleNum(vector<int> nums, int n)
    {
        int res;
        vector<int> count(32);//统计每位上1的总个数，int共32位
        for(auto x : nums)
        {
            for(int i(0); i <32; i++) count[i] += (x>>i)&1;
        }
        for(int i(0); i<32; i++)//只要是3的倍数，该位就置0
            if(count[i]%n != 0) res |= 1<<i;
        return res;
    }
    ```
# 动态规划

## 1 背包问题

- **循环的顺序：物品（组）---> 体积 ---> 决策**

- 代码上第一维都是循环物品，第二维是循环体积 
- 0-1背包：每件物品最多用一次，容量是从大到小枚举
- 完全背包：每件物品无限个，容量是从小到大枚举
- 多重背包：每件物品的数量不定，需要用到二进制优化，然后转化为01背包问题
    1. 将s个物品打包为`log(s)`（向上取整）个新的物品组，用它们可以凑出0~s的任何一个数
    2. 时间复杂度O(s)--->O(lgs)
    3. 打包方法：不需要使用最笨的办法进行划分，比如s=10,不需要划分成10个单独的包，而是（1,2,4,3）这么对应的4个包

```cpp
using PII = pair<int, int>;
vector<PII> goods;  // 存储拆分后物品对应的 体积 和对应 价值
int main() {
    cin >> n >> m;
    while(n--) {
        int v, w, s;
        // 多重背包拆分为01背包问题
        for(int k = 1; k <= s; k *= 2) {
            goods.push_back({k*v, k*w});
            s -= k;
        }
        if(s > 0) goods.push_back({s*v, s*w});
    }// 拆分完成，下面就按01背包做就可以了
}
```

- 分组背包：每组物品的数量不定，但是每组里面只能选择一个物品

```cpp
1. 0-1背包： f[i][j] = max(f[i-1][j], f[i-1][j-v] + w);
2. 完全背包： f[i][j] = max(f[i-1][j], f[i][j-v] + w);
3. 多重背包： 枚举第i个物品选取多少个
4. 分组背包： 枚举第i组物品选哪个；循环顺序：物品组--》体积--》决策（该物品组中选哪一个）
```

## 2 线性DP

- 集合划分：可以考虑倒数第二个选哪个对象

## 3 区间DP

- 状态定义为一个区间
- 区间循环：一般先循环区间的长度，然后循环左端点，这样右端点就定下来了

## 4 计数类DP

- 注意能不能转化为背包问题

## 5 数位统计DP

- 分情况讨论

## 6 状态压缩DP


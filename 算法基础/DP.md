# 动态规划

## 1 背包问题

- 0-1背包：每件物品最多用一次
- 完全背包：每件物品无限个
- 多重背包：每件物品的数量不定，需要用到二进制优化，然后转化为01背包问题
    1. 将s个物品打包为`log(s)`（向上取整）个新的物品组，用它们可以凑出0~s的任何一个数
    2. 时间复杂度O(s)--->O(lgs)
    3. 打包方法：

    >```cpp
    >int cnt = 0;   // 编号
    >for(int i=1; i<=n; i++) {
    >    int a, b, s;
    >    cin >> a >> b >> s;
    >    int k = 1;
    >    // 对s进行拆分
    >    while(k <= s) {
    >        cnt++;
    >        v[cnt] = k * a, w[cnt] = k * b;
    >        s -= k, k *= 2;
    >    }
    >    if(s > 0) {
    >        cnt++;
    >        v[cnt] = s * a, w[cnt] = s* b;
    >    }
    >}
    >```

- 分组背包：每组物品的数量不定，但是每组里面只能选择一个物品

```cpp
1. 0-1背包： f[i][j] = max(f[i-1][j], f[i-1][j-v] + w);
2. 完全背包： f[i][j] = max(f[i-1][j], f[i][j-v] + w);
3. 多重背包： 枚举第i个物品选取多少个
4. 分组背包： 枚举第i组物品选哪个
```

## 2 线性DP

- 集合划分：可以考虑倒数第二个选哪个对象

## 3 区间DP

- 状态定义为一个区间
- 区间循环：一般先循环区间的长度，然后循环左端点，这样右端点就定下来了

## 4 计数类DP

- 注意能不能转化为背包问题

## 5 数位统计DP

- 分情况讨论

## 6 状态压缩DP、


# 数据结构

## 1 链表与邻接表

### 1.1 单链表

- 数组模拟的链表称为静态链表

```cpp
// head存储链表头
//e[]存储节点的值
//ne[]存储节点的next指针
//idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init() {
    head = -1;
    idx = 0;
}

// 头插
void insertTohead(int a) {
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
// 同理，在第k个结点后面插入x
void insert(int k, int x) {
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx++;
}

// 将头结点删除，需要保证头结点存在
void remove() {
    head = ne[head];
}
// 同理， 删除第k个结点, 下标是k-1
void remove(int k-1) {
    ne[k-1] = ne[ne[k-1]];
}
```

### 1.2 双链表

```cpp
// e[]表示节点的值
//l[]表示节点的左指针
//r[]表示节点的右指针
//idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init() {
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x) {
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a) {
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```

## 2 栈与队列

### 2.1 栈

```cpp
// tt表示栈顶
int stk[N], tt = 0;
// 向栈顶插入一个元素
stk[++tt] = X;
// 从栈顶弹出一个元素
tt--;
// 栈顶的值
stk[tt];
// 判断栈顶是否为空
if(tt > 0) {

}
```

### 2.2 队列

1. 普通队列

    ```cpp
    // hh 表示队头， tt表示队尾
    int q[N], hh = 0, tt = -1;
    // 向队尾插入一个元素
    q[++tt] = x;
    // 从队头弹出一个数
    hh++;
    // 队头的值
    q[hh];
    // 判断队列是否为空
    if(hh <= tt) {

    }
    ```

2. 循环队列

    ```cpp
    // hh表示队头， tt表示队尾的后一个位置
    int q[N], hh = 0, tt = 0;
    // 向队尾插入一个数
    q[tt++] = x;
    if(tt == N) tt = 0;
    // 从队头弹出一个数
    hh++;
    if(hh == N) hh = 0;
    // 队头的值
    q[hh];
    // 判断队列是否为空
    if(hh != tt) {

    }
    ```

### 2.3 单调栈与单调队列

1. 单调栈

   - 常见模型：找出每个数左边离它最近的比它大/小的数

    ```cpp
    int tt = 0;
    for (int i = 1; i <= n; i ++ ) {
        while (tt && check(stk[tt], i)) tt -- ;
        stk[ ++ tt] = i;
    }
    ```

2. 单调队列

   - 常见模型：找出滑动窗口中的最大值/最小值

    ```cpp
    int hh = 0, tt = -1;
    for(int i=0; i<n; i++) {
        while(hh <= tt && checkOut(q[hh])) hh++; // 判断队头是否滑出窗口
        while(hh <= tt && check(q[tt], i)) tt--;
        q[++tt] = i;
    }
    ```

## 3 kmp

```cpp
// s[] 是长文本，p[]是模式串，n=s.size(), m=p.size()
// 求模式串的next[]
for(int i=2, j=0; i<=m; i++) {
    while(j && p[i]!=p[j+1]) j = ne[j];
    if(p[i] == p[j+1]) j++;
    ne[i] = j;
}
// 匹配
for(int i=1, j=0; i<=n; i++) {
    while(j && s[i]!=p[j+1]) j = ne[j];
    if(s[i] == p[j+1]) j++;
    if(j == m) {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}
```

## 4 Trie

- 高效的存储和查找字符串集合的数据结构

## 5 并查集

## 6 堆

## 7 Hash表

## 8 STL技巧
